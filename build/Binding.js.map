{"version":3,"sources":["../src/Binding.js"],"names":["Binding","constructor","forge","name","lifecycle","arguments","type","target","resolver","function","instance","singleton","transient","with","args","when","condition","Function","predicate","hint","matches","resolve","context","has","push","result","pop","toString","tokens","dependencies","length","deps","map","dep","join","sweeten","property","Object","defineProperty","prototype","get"],"mappings":"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","file":"Binding.js","sourcesContent":["import ensure from './util/ensure';\nimport FunctionResolver from './resolvers/FunctionResolver';\nimport InstanceResolver from './resolvers/InstanceResolver';\nimport TypeResolver from './resolvers/TypeResolver';\nimport SingletonLifecycle from './lifecycles/SingletonLifecycle';\nimport TransientLifecycle from './lifecycles/TransientLifecycle';\nimport ConfigurationError from './errors/ConfigurationError';\nimport ResolutionError from './errors/ResolutionError';\n\nclass Binding {\n\n  constructor(forge, name) {\n    ensure('forge', forge);\n    ensure('name', name);\n    this.forge = forge;\n    this.name = name;\n    this.lifecycle = new SingletonLifecycle(); // default\n    this.arguments = {};\n  }\n\n  type(target) {\n    ensure('target', target);\n    this.resolver = new TypeResolver(this.forge, this, target);\n    return this;\n  }\n\n  function(target) {\n    ensure('target', target);\n    this.resolver = new FunctionResolver(this.forge, this, target);\n    return this;\n  }\n\n  instance(target) {\n    ensure('target', target);\n    this.resolver = new InstanceResolver(this.forge, this, target);\n    return this;\n  }\n\n  singleton() {\n    this.lifecycle = new SingletonLifecycle();\n    return this;\n  }\n\n  transient() {\n    this.lifecycle = new TransientLifecycle();\n    return this;\n  }\n\n  with(args) {\n    ensure('args', args);\n    this.arguments = args;\n    return this;\n  }\n\n  when(condition) {\n    ensure('condition', condition);\n    if (condition instanceof Function) {\n      this.predicate = condition;\n    } else {\n      this.predicate = hint => hint == condition;\n    }\n    return this;\n  }\n\n  matches(hint) {\n    return this.predicate ? this.predicate(hint) : true;\n  }\n\n  resolve(context, hint, args = {}) {\n    ensure('context', context);\n\n    if (this.lifecycle == null) {\n      throw new ConfigurationError(this.name, 'No lifecycle defined');\n    }\n\n    if (this.resolver == null) {\n      throw new ConfigurationError(this.name, 'No resolver defined');\n    }\n\n    if (context.has(this)) {\n      throw new ResolutionError(this.name, hint, context, 'Circular dependencies detected');\n    }\n\n    context.push(this);\n    const result = this.lifecycle.resolve(this.resolver, context, args);\n    context.pop();\n\n    return result;\n  }\n\n  toString() {\n    const tokens = [];\n    if (this.predicate) { tokens.push('(conditional)'); }\n\n    tokens.push(this.name);\n    tokens.push('->');\n    tokens.push(this.resolver ? this.resolver.toString() : '<undefined resolver>');\n    tokens.push(`(${this.lifecycle.toString()})`);\n\n    if (this.resolver && this.resolver.dependencies && this.resolver.dependencies.length > 0) {\n      const deps = this.resolver.dependencies.map(dep => dep.hint ? `${dep.name}:${dep.hint}` : dep.name);\n      tokens.push(`depends on: [${deps.join(', ')}]`);\n    }\n\n    return tokens.join(' ');\n  }\n\n}\n\n// <binding>.to.type() and <binding>.as.singleton() are really just syntactic sugar.\nconst sweeten = function(type, property) {\n  return Object.defineProperty(type.prototype, property, {\n    get() { return this; }\n  });\n};\n\nsweeten(Binding, 'to');\nsweeten(Binding, 'as');\n\nexport default Binding;\n"]}