// Generated by CoffeeScript 1.10.0
(function() {
  var Binding, ConfigurationError, FunctionResolver, InstanceResolver, ResolutionError, SingletonLifecycle, TransientLifecycle, TypeResolver, _, assert, chain, sweeten,
    slice = [].slice;

  assert = require('assert');

  _ = require('underscore');

  FunctionResolver = require('./resolvers/FunctionResolver');

  InstanceResolver = require('./resolvers/InstanceResolver');

  TypeResolver = require('./resolvers/TypeResolver');

  SingletonLifecycle = require('./lifecycles/SingletonLifecycle');

  TransientLifecycle = require('./lifecycles/TransientLifecycle');

  ConfigurationError = require('./errors/ConfigurationError');

  ResolutionError = require('./errors/ResolutionError');

  sweeten = function(type, property) {
    return Object.defineProperty(type.prototype, property, {
      get: function() {
        return this;
      }
    });
  };

  chain = function(func) {
    return function() {
      var args, result;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      result = func.apply(this, args);
      return this;
    };
  };

  Binding = (function() {
    function Binding(forge, name) {
      this.forge = forge;
      this.name = name;
      assert(this.forge != null, 'The argument "forge" must have a value');
      assert(this.name != null, 'The argument "name" must have a value');
      this.lifecycle = new SingletonLifecycle();
      this["arguments"] = {};
    }

    Binding.prototype.matches = function(hint) {
      if (this.predicate != null) {
        return this.predicate(hint);
      } else {
        return true;
      }
    };

    Binding.prototype.resolve = function(context, hint, args) {
      var result;
      if (args == null) {
        args = {};
      }
      assert(context, 'The argument "context" must have a value');
      if (this.lifecycle == null) {
        throw new ConfigurationError(this.name, 'No lifecycle defined');
      }
      if (this.resolver == null) {
        throw new ConfigurationError(this.name, 'No resolver defined');
      }
      if (context.has(this)) {
        throw new ResolutionError(this.name, hint, context, 'Circular dependencies detected');
      }
      context.push(this);
      result = this.lifecycle.resolve(this.resolver, context, args);
      context.pop();
      return result;
    };

    sweeten(Binding, 'to');

    sweeten(Binding, 'as');

    Binding.prototype.type = chain(function(target) {
      assert(target != null, 'The argument "target" must have a value');
      return this.resolver = new TypeResolver(this.forge, this, target);
    });

    Binding.prototype["function"] = chain(function(target) {
      assert(target != null, 'The argument "target" must have a value');
      return this.resolver = new FunctionResolver(this.forge, this, target);
    });

    Binding.prototype.instance = chain(function(target) {
      assert(target != null, 'The argument "target" must have a value');
      return this.resolver = new InstanceResolver(this.forge, this, target);
    });

    Binding.prototype.singleton = chain(function() {
      return this.lifecycle = new SingletonLifecycle();
    });

    Binding.prototype.transient = chain(function() {
      return this.lifecycle = new TransientLifecycle();
    });

    Binding.prototype.when = chain(function(condition) {
      assert(condition != null, 'The argument "condition" must have a value');
      if (_.isFunction(condition)) {
        return this.predicate = condition;
      } else {
        return this.predicate = function(hint) {
          return hint === condition;
        };
      }
    });

    Binding.prototype["with"] = chain(function(args) {
      return this["arguments"] = args;
    });

    Binding.prototype.toString = function() {
      var deps, ref, tokens;
      tokens = [];
      if (this.predicate != null) {
        tokens.push('(conditional)');
      }
      tokens.push(this.name);
      tokens.push('->');
      tokens.push(this.resolver != null ? this.resolver.toString() : '<undefined resolver>');
      tokens.push("(" + (this.lifecycle.toString()) + ")");
      if (((ref = this.resolver.dependencies) != null ? ref.length : void 0) > 0) {
        deps = _.map(this.resolver.dependencies, function(dep) {
          if (dep.hint != null) {
            return dep.name + ":" + dep.hint;
          } else {
            return dep.name;
          }
        });
        tokens.push("depends on: [" + (deps.join(', ')) + "]");
      }
      return tokens.join(' ');
    };

    return Binding;

  })();

  module.exports = Binding;

}).call(this);
